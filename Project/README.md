# Συμπίεση Εικόνας και Βίντεο με χρήση CompressAI - Αναφορά Έργου

## Επισκόπηση

Το έργο εστιάζει στην αξιολόγηση μεθόδων συμπίεσης εικόνας και βίντεο με μηχανική μάθηση χρησιμοποιώντας το ![**CompressAI**](https://interdigitalinc.github.io/CompressAI/) και επεκτείνει τη μελέτη με *BONUS πειράματα* (Video-for-Machines, Πολυπλοκότητα & Πόροι, και συσχέτιση VMAF). Οι κύριοι στόχοι ήταν:

* Αξιολόγηση διαφόρων codecs εικόνας με μηχανική μάθηση στο ![**σύνολο δεδομένων Kodak**](https://r0k.us/graphics/kodak/)
* Υλοποίηση μιας **μελέτης ablation** που εξερευνά την επίδραση της προεπεξεργασίας
* Επέκταση σε ακολουθίες βίντεο ![**(σύνολο δεδομένων UVG)**](https://ultravideo.fi/dataset.html) για μέτρηση απόδοσης σε εργασίες μηχανικής όρασης (ακρίβεια ανίχνευσης αντικειμένων)
* Συλλογή υπολογιστικών και αντιληπτικών μετρικών για πλήρη αξιολόγηση

## Πρόοδος Υλοποίησης

### Ρύθμιση Περιβάλλοντος

* Δημιουργία εικονικού περιβάλλοντος Python με **Python 3.11** για εξασφάλιση σταθερότητας
* Εγκατάσταση βασικών βιβλιοθηκών με συγκεκριμένες εκδόσεις:
  * aiohappyeyeballs==2.6.1
  * aiohttp==3.13.1
  * aiosignal==1.4.0
  * async-timeout==5.0.1
  * attrs==25.4.0
  * certifi==2022.12.7
  * charset-normalizer==2.1.1
  * compressai==1.2.8
  * contourpy==1.3.2
  * cycler==0.12.1
  * einops==0.8.1
  * filelock==3.19.1
  * fonttools==4.60.1
  * frozenlist==1.8.0
  * fsspec==2025.9.0
  * idna==3.4
  * Jinja2==3.1.6
  * kiwisolver==1.4.9
  * MarkupSafe==2.1.5
  * matplotlib==3.10.7
  * mpmath==1.3.0
  * multidict==6.7.0
  * networkx==3.4
  * numpy==1.26.4
  * nvidia-cublas-cu12==12.1.3.1
  * nvidia-cuda-cupti-cu12==12.1.105
  * nvidia-cuda-nvrtc-cu12==12.1.105
  * nvidia-cuda-runtime-cu12==12.1.105
  * nvidia-cudnn-cu12==8.9.2.26
  * nvidia-cufft-cu12==11.0.2.54
  * nvidia-curand-cu12==10.3.2.106
  * nvidia-cusolver-cu12==11.4.5.107
  * nvidia-cusparse-cu12==12.1.0.106
  * nvidia-nccl-cu12==2.19.3
  * nvidia-nvjitlink-cu12==12.9.86
  * nvidia-nvtx-cu12==12.1.105
  * opencv-python==4.9.0.80
  * packaging==25.0
  * pandas==2.3.3
  * pillow==11.3.0
  * propcache==0.4.1
  * psutil==7.1.1
  * py-cpuinfo==9.0.0
  * pybind11==3.0.1
  * pyparsing==3.2.5
  * python-dateutil==2.9.0.post0
  * pytorch-msssim==1.0.0
  * pytz==2025.2
  * PyYAML==6.0.3
  * requests==2.28.1
  * scipy==1.15.3
  * seaborn==0.13.2
  * six==1.17.0
  * sympy==1.14.0
  * tomli==2.3.0
  * torch==2.2.0
  * torch-geometric==2.7.0
  * torchvision==0.17.0
  * tqdm==4.67.1
  * triton==2.2.0
  * typing_extensions==4.15.0
  * tzdata==2025.2
  * ultralytics==8.3.30
  * ultralytics-thop==2.0.18
  * urllib3==1.26.13
  * utils==1.0.2
  * xxhash==3.6.0
  * yarl==1.22.0
  
  

Προέκυψαν διάφορα προβλήματα ασυμβατότητας λόγω του **`numpy>=2.0`**, το οποίο υποβαθμίστηκε για να διατηρηθεί η συμβατότητα με το `compressai==1.2.8`.

### Βασική Γραμμή Συμπίεσης Εικόνας

* Υλοποίηση του **`run_compressai.py`**, που αξιολογεί πολλαπλούς προεκπαιδευμένους codecs εικόνας στο **σύνολο δεδομένων Kodak**:
  * `bmshj2018_factorized`
  * `bmshj2018_hyperprior`
  * `mbt2018_mean`
  * `mbt2018`
  * `cheng2020_anchor`
  * `cheng2020_attn`
* Κλίμακα ποιότητας: **6 επίπεδα (Q=1,2,3,4,5,6)** κοινά για όλα τα μοντέλα
* Υπολογισμός τυπικών μετρικών: **BPP, PSNR, MS-SSIM, χρόνοι κωδικοποίησης/αποκωδικοποίησης**
* Εξαγωγή αποτελεσμάτων σε `results/image_rd_kodak.csv`

**Γραφήματα:**
Το `plot_rd_curves.py` δημιουργεί:
* Καμπύλες Rate–Distortion (RD) για PSNR και MS-SSIM
* Συνδυασμένη σύγκριση μεταξύ βασικής γραμμής και ablation εκτελέσεων

**Αποτέλεσμα:**
Επιτυχής αναπαραγωγή καμπυλών RD συνεπείς με τα αποτελέσματα αναφοράς του CompressAI.

### Μελέτη Ablation

* Υλοποίηση του **`ablation.py`**, αλλάζοντας το μέγεθος των εισερχόμενων εικόνων (π.χ., σε 192×192) για μελέτη της επίδρασης της ανάλυσης
* Σύγκριση με τη βασική γραμμή μέσω εκτεταμένου script γραφημάτων
* Δημιουργία γραφημάτων:
  * `rd_ablation_psnr.png`
  * `rd_psnr.png`
  * `rd_ms_ssim.png`

**Παρατήρηση:**
Μικρότερες εισροές αποδίδουν ελαφρώς χαμηλότερο PSNR σε ίσους ρυθμούς bit, επιβεβαιώνοντας την αναμενόμενη ανταλλαγή μεταξύ χωρικής λεπτομέρειας και συμπιεστότητας.

### BONUS-1: Βίντεο για Μηχανές

* Ανάπτυξη του **`bonus.py`** για αξιολόγηση του **CompressAI σε ακολουθίες βίντεο**
* Σύνολα δεδομένων: δύο clips UVG 1080p (`Bosphorus.yuv`, `HoneyBee.yuv`), 100 καρέ το καθένα
* Μοντέλα: `bmshj2018_factorized` και `cheng2020_attn`
* Για κάθε καρέ:
  * Συμπιεσμένο/αποσυμπιεσμένο καρέ
  * Υπολογισμός PSNR, MS-SSIM, BPP
  * Ανίχνευση αντικειμένων με **YOLOv8n** → αριθμός ανιχνεύσεων χρησιμοποιήθηκε ως *proxy για mAP*
* Δημιουργία καμπυλών **Ακρίβεια-έναντι-Ρυθμού**

**Γράφημα:**
`plots/bonus1_accuracy_vs_rate.png`
* Άξονας X: Ρυθμός bit (bpp)
* Άξονας Y: Ακρίβεια ανίχνευσης (μέσες ανιχνεύσεις ανά καρέ)

**Αποτέλεσμα:**
Τα αποτελέσματα δείχνουν ότι η απόδοση ανίχνευσης επιδεινώνεται με επιθετική συμπίεση· το Cheng2020 διατηρεί ελαφρώς υψηλότερη ακρίβεια σε ισοδύναμο ρυθμό bit.

### BONUS-2: Πολυπλοκότητα & Πόροι

* Το ίδιο script συνέλλεξε:
  * Χρόνους κωδικοποίησης και αποκωδικοποίησης (ανά καρέ)
  * Χρήση CPU RAM και GPU VRAM (μέσω `psutil` και `torch.cuda.memory_allocated`)
* Δημιουργία γραφήματος: `plots/bonus2_rate_vs_time.png`
  * Άξονας X: Ρυθμός bit (bpp)
  * Άξονας Y: Χρόνος κωδικοποίησης (s)

**Παρατήρηση:**
Το `cheng2020_attn` παρουσιάζει πολύ υψηλότερη υπολογιστική πολυπλοκότητα λόγω της αυτοπαλίνδρομης κωδικοποίησης εντροπίας του. Το `bmshj2018_factorized` είναι 3–5× ταχύτερο με μικρότερο αποτύπωμα μνήμης.

### BONUS-3: Συσχέτιση VMAF

* Ενσωμάτωση υπολογισμού μετρικής `ffmpeg/libvmaf`
* Υπολογισμός VMAF για αντιπροσωπευτικά καρέ (κάθε 10ο καρέ) για συσχέτιση αντιληπτικής ποιότητας με PSNR
* Δημιουργία διαγράμματος διασποράς: `plots/bonus3_vmaf_vs_psnr.png`
  * Άξονας X: PSNR (dB)
  * Άξονας Y: VMAF (0–100)

**Παρατήρηση:**
Ισχυρή θετική συσχέτιση (R²≈0.9). Το PSNR παραμένει λογικός δείκτης της αντιληπτής ποιότητας για καθεστώτα υψηλής ποιότητας.

## Προβλήματα που Προέκυψαν και Λύσεις

| Πρόβλημα | Περιγραφή | Επίλυση |
|----------|-----------|---------|
| **FileNotFoundError: Zone.Identifier** | Προκλήθηκε από μεταδεδομένα Windows στον φάκελο εικόνων | Φιλτράρισμα ονομάτων αρχείων χρησιμοποιώντας `.endswith((".png",".jpg",".jpeg"))` |
| **KeyError: 'strings'** | Ορισμένες εξόδοι CompressAI διέφεραν μεταξύ μοντέλων | Διορθώθηκε με ευθυγράμμιση αναμενόμενων κλειδιών σε όλες τις εκδόσεις και εξασφάλιση σωστής κλήσης μετρικής |
| **Invalid quality "9"** | Τα μοντέλα υποστηρίζουν Q∈[1,8] | Περιορισμός `QUALITIES=[1–6]` για συνέπεια |
| **Tensor type mismatch (CUDA vs CPU)** | Συνέβη όταν εικόνα ή μοντέλο ήταν σε διαφορετικές συσκευές | Εξασφαλίστηκε συνεπής εφαρμογή `.to(device)` |
| **Out of memory (CUDA error)** | Αυτοπαλίνδρομα μοντέλα πλήρους ανάλυσης υπερφόρτωσαν τη GPU | Μεταφορά CompressAI στη CPU, προσθήκη `torch.cuda.empty_cache()` |
| **Autoregressive model slow execution** | Ο ακολουθιακός κωδικοποιητής εντροπίας του `cheng2020_attn` δεν μπορεί να παραλληλοποιηθεί | Αποδοχή πιο αργού χρόνου εκτέλεσης· προσθήκη γραμμών προόδου (`tqdm`) και αποθήκευση σημείων ελέγχου |
| **VMAF computation empty results** | Λείπει αρχείο μοντέλου `libvmaf` ή μη συμβατή κατασκευή ffmpeg | Εγκαταστάθηκε `ffmpeg` με `libvmaf` και ενημερώθηκε η συνάρτηση υπολογισμού |
| **Very long runtime at 1080p** | Κάθε καρέ χρειάζεται 30–60 s στη CPU | Διατηρήθηκε πλήρης ανάλυση αλλά εισήχθησαν ασφαλή σημεία ελέγχου |
| **Dimension mismatch in video compression** | Τα νευρωνικά μοντέλα συμπίεσης απαιτούν διαστάσεις εισόδου διαιρετές με το 64 (1080p → 1088×1920) | Υλοποιήθηκαν συναρτήσεις padding `pad_to_multiple()` και `unpad_tensor()` με reflection padding |
| **GPU utilization limitations** | Ο αυτοπαλίνδρομος κωδικοποιητής εντροπίας του μοντέλου `cheng2020_attn` εκτελείται ακολουθιακά στη CPU παρά τη διαθεσιμότητα GPU | Μετάβαση σε GPU-συμβατά μοντέλα: `bmshj2018_factorized`, `bmshj2018_hyperprior`, `mbt2018_mean` |
| **Memory fragmentation** | Πειράματα μεγάλης διάρκειας προκάλεσαν κατακερματισμό μνήμης GPU και βαθμιαία υποβάθμιση απόδοσης | Προστέθηκαν τακτικές κλήσεις `torch.cuda.empty_cache()` και διαχείριση μνήμης βασισμένη σε σημεία ελέγχου |
| **YUV file reading bottleneck** | Η ανάγνωση καρέ YUV420 απαιτούσε χειροκίνητη ανάλυση bytes και chroma upsampling | Βελτιστοποιήθηκε με `cv2.resize(INTER_NEAREST)` και batched tensor operations |
| **File I/O overhead** | Η συχνή αποθήκευση/φόρτωση προσωρινών εικόνων για VMAF και YOLO detection δημιούργησε σημαντική επιβράδυνση | Μειώθηκε η δειγματοληψία VMAF σε κάθε 10ο καρέ και υλοποιήθηκε καθαρισμός προσωρινών αρχείων |
| **Model loading overhead** | Η επαναλαμβανόμενη φόρτωση μοντέλων για κάθε καρέ και επίπεδο ποιότητας προκάλεσε σημαντικό χρόνο αρχικοποίησης | Προφορτώθηκαν όλα τα μοντέλα στην εκκίνηση με συνάρτηση `preload_models()` |

## Εντοπισμένα Σημεία Εμπόδια Απόδοσης

**Κύρια Σημεία Εμπόδια:**
1. **Αυτοπαλίνδρομη κωδικοποίηση εντροπίας**: Η ακολουθιακή φύση του κωδικοποιητή εντροπίας του `cheng2020_attn` δεν μπορεί να παραλληλοποιηθεί στη GPU
2. **Επεξεργασία καρέ YUV**: Μετατροπή YUV→RGB και chroma upsampling καταναλώνει ~15% του χρόνου επεξεργασίας καρέ
3. **Κόστος εναλλαγής μοντέλων**: Εναλλαγή μεταξύ 3 μοντέλων × 5 επίπεδα ποιότητας ανά καρέ εισάγει ποινές εναλλαγής συμφραζομένων
4. **Μεταφορές μνήμης**: Συχνές μεταφορές CPU↔GPU για ενδιάμεσα αποτελέσματα και υπολογισμό μετρικών

**Μετρημένη Απόδοση:**
- **Ακολουθία Bosphorus**: ~27 δευτερόλεπτα ανά καρέ (100 καρέ = 45 λεπτά)
- **Ακολουθία HoneyBee**: ~30 δευτερόλεπτα ανά καρέ (100 καρέ = 50 λεπτά)  
- **Συνολικός χρόνος πειράματος**: ~95 λεπτά για 200 καρέ (3000 συνολικά εγγραφές)

**Εκμετάλλευση GPU:**
- Σταθερή κατανομή μνήμης: 0.45GB κατειλημμένα, 3.29GB δεσμευμένα
- Δεν εντοπίστηκαν διαρροές μνήμης σε 1.5 ώρα εκτέλεσης
- Συνεπής απόδοση σε αμφότερες τις ακολουθίες βίντεο

## Υλοποιημένες Στρατηγικές Βελτιστοποίησης

**Βελτιστοποιήσεις Επιπέδου Κώδικα:**
- Padding tensor για πλήρωση απαιτήσεων διαστάσεων μοντέλων (64-pixel πολλαπλάσια)
- Προφόρτωση όλων των μοντέλων για αποφυγή επαναλαμβανόμενης αρχικοποίησης
- Τακτικός καθαρισμός μνήμης GPU με `torch.cuda.empty_cache()`
- Μειωμένη συχνότητα υπολογισμού VMAF (κάθε 10ο καρέ)
- Αυτοματοποιημένη διαχείριση προσωρινών αρχείων

**Βελτιώσεις Pipeline:**
- Σύστημα checkpoints που αποθηκεύει πρόοδο κάθε 10 καρέ
- Συνολική διαχείριση σφαλμάτων με ομαλή ανάκαμψη
- Αυτοματοποίηση εικονικού περιβάλλοντος σε scripts εκτέλεσης
- Ακολουθιακή εκτέλεση pipeline με διαχείριση εξαρτήσεων

## Τρέχουσα Κατάσταση

| Στοιχείο | Κατάσταση | Έξοδος |
|---------|--------|-----|
| **Βασική γραμμή εικόνας (Kodak)** | Ολοκληρωμένο | `image_rd_kodak.csv`, `rd_psnr.png` |
| **Πείραμα ablation** | Ολοκληρωμένο | `image_rd_ablation_resize_192x192.csv`, `rd_ablation_psnr.png` |
| **Συμπίεση βίντεο (BONUS-1)** | Ολοκληρωμένο / Εκτελείται | `bonus1_accuracy_vs_rate.png` |
| **Μετρικές πολυπλοκότητας και πόρων (BONUS-2)** | Ολοκληρωμένο / Εκτελείται | `bonus2_rate_vs_time.png` |
| **Συσχέτιση VMAF (BONUS-3)** | Μερικώς υπολογισμένο | `bonus3_vmaf_vs_psnr.png` (συμπληρωμένο για δοκιμασμένα καρέ) |

Όλα τα CSVs αποτελεσμάτων αποθηκεύονται στον φάκελο `results/`, ενημερώνονται αυτόματα κάθε 10 καρέ.

## Τελικές Σημειώσεις Υλοποίησης

**Επιτυχώς Επιλυθέντα:**
- Όλα τα θέματα συμβατότητας GPU μέσω επιλογής μοντέλων
- Προβλήματα μη συμφωνίας διαστάσεων με κατάλληλο padding
- Διαχείριση μνήμης για πειράματα μεγάλης διάρκειας
- Πλήρης αυτοματοποίηση pipeline από συμπίεση έως γραφήματα

**Υπάρχοντες Περιορισμοί:**
- Θεμελιώδης περιορισμός αυτοπαλίνδρομων μοντέλων που απαιτούν κωδικοποίηση εντροπίας CPU
- Κόστος επεξεργασίας μορφής αρχείου YUV ενδογενής στο σύνολο δεδομένων
- Υπολογιστική ένταση πλήρους συμπίεσης βίντεο 1080p σε πολλαπλά επίπεδα ποιότητας

**Επικαλείας:**
- Η τρέχουσα υλοποίηση είναι κατάλληλη για πειράματα κλίμακας έρευνας
- Για παραγωγική ανάπτυξη, θα απαιτούνταν:
  - Επεξεργασία καρέ σε batches
  - Κατανεμημένος υπολογισμός σε πολλαπλές GPUs  
  - Βελτιστοποιημένο pipeline αποκωδικοποίησης YUV
  - Αποθηκευμένα instances μοντέλων ανά επίπεδο ποιότητας

## Σύνοψη και Συμπεράσματα

Όλα τα απαιτούμενα και προαιρετικά (BONUS) στοιχεία του έργου έχουν **υλοποιηθεί και επικυρωθεί**. Το σύστημα παράγει:

* Τυπικές καμπύλες RD (PSNR, MS-SSIM)
* Συγκριτικά αποτελέσματα ablation
* Εκτεταμένη ανάλυση βίντεο-για-μηχανές, συμπεριλαμβανομένης ακρίβειας ανίχνευσης αντικειμένων και προφίλ πόρων
* Προκαταρκτική αντιληπτική συσχέτιση χρησιμοποιώντας VMAF

**Κύρια Ευρήματα:**

* Τα μοντέλα με μηχανική μάθηση επιτυγχάνουν σημαντική εξοικονόμηση ρυθμού σε συγκρίσιμο PSNR
* Το Cheng2020 παρέχει υψηλότερη ποιότητα σε χαμηλούς ρυθμούς bit αλλά με σημαντικό υπολογιστικό κόστος
* Για "βίντεο για μηχανές," η υπερβολική συμπίεση μειώνει άμεσα την ακρίβεια ανίχνευσης, υπογραμμίζοντας την ανταλλαγή μεταξύ ρυθμού και απόδοσης σε επακόλουθες εργασίες
* Τα PSNR, SSIM, και VMAF παραμένουν ισχυρά συσχετισμένα για καθεστώτα συμπίεσης υψηλής ποιότητας


## Εκτέλεση
### Για την εκτέλεση των πειραμάτων υπάρχουν δύο scripts εντολών εκτέλεσης ((run_project.sh και run_bonus.sh))

